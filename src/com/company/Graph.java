package com.company;

public class Graph {

//https://www.youtube.com/watch?v=LCrovIMurxY&list=PLgUwDviBIf0rGEWe64KWas0Nryn7SCRWw&index=2&ab_channel=takeUforward

//undirected graph
// degrees: no of outgoing or incoming edges
// total number of degrees of all the nodes is equal to the 2*degree
// path - such that no 2 modes repeat
// undirected cyclic and asylic(tree- no cycle in the graph)


//directed graph either incoming or outgoing edges
// directed sylic graph( DAG)

// representation of graph
// https://www.youtube.com/watch?v=bTtm2ky7I3Y&list=PLgUwDviBIf0rGEWe64KWas0Nryn7SCRWw&index=3&ab_channel=takeUforward

// in c++
/*

cin>> n>>m;

int adj[n+1][n+1];// initialised all with 0

for( int i=0; i<m; i++){
int u,v;

cin>>u>>v;
adj[u][v]=1;
adj[v][u]=1
}

for 5 nodes we create a vector array of size 5+1

vector<int> adj[6];


cin>>n>>m;

vector<pair<int,int> adj[n+1];

for( int i=0, i<m;i++){
int u,v,w;
cin>>u>>v>>w;
adj[u].pushback({v,w});
adj[v]/push_back({u,w});
}


// in java

Arraylist<ArrayList<Integer>> adj= new ArrayList<Integer>>();

for( int i=0; i<= n;i++){
adj.add(new ArrayList<>());
}

for( int i=0; i<m; i++){
adj.get(u).add(v);
adj.get(v).add(u);
}
}


bfs and dfs
//https://www.youtube.com/watch?v=pcKY4hjDrxk&ab_channel=AbdulBari

bfs is like level order and dfs is pre order

bfs queue
dfs stack

for( int i=0; i<n; i++){

int beg=3, end -]==9
}
}

 */
}
